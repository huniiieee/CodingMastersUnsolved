문제:(이분매칭)
부산국제영화제에 여러 개봉작들이 출품되었습니다. 
심사위원들은 여러 작품들 중에서 우수한 작품을 골라 작품상을 수상하려고 합니다. 
심사할 포인트는 예술성, 대중성, 시나리오이고, 서로 다른 두 작품을 비교하여 한 작품이 다른 작품과 비교하여 세 가지 심사 포인트 점수가 같거나 큰 경우 다른 작품이 떨어지는 방식을 취합니다. 
단 공정성을 위해 한 작품이 최대 두 개의 다른 작품만 떨어뜨릴 수 있게 합니다. N개 출품작들의 세 가지 포인트 점수가 주어졌을 때, 작품상을 수상하는 작품의 최소 개수를 구하세요.

답안:
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.util.*;

public class Main {

    public static final BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
    public static final StringBuilder sb = new StringBuilder();
    public static StringTokenizer st;

    private int N;
    private int[][] nodes;
    private ArrayList<Integer>[] edges;
    private int[] removed;
    private boolean[] isVisited;
    private int delCount;

    private boolean execDFS(int curNodeNum) {

        for (int next : edges[curNodeNum]) {
            if (isVisited[next]) {
                continue;
            }
            isVisited[next] = true;
            if (removed[next] == -1 || execDFS(removed[next])) {
                removed[next] = curNodeNum;
                return true;
            }
        }

        return false;
    }

    private void solution() throws IOException {

        N = Integer.parseInt(br.readLine());
        nodes = new int[N][3];
        for (int i = 0; i < N; i++) {
            st = new StringTokenizer(br.readLine());
            nodes[i][0] = Integer.parseInt(st.nextToken());
            nodes[i][1] = Integer.parseInt(st.nextToken());
            nodes[i][2] = Integer.parseInt(st.nextToken());
        }

        edges = new ArrayList[N];
        for (int i = 0; i < N; i++) {
            edges[i] = new ArrayList();
        }
        for (int i = 0; i < N; i++) {
            for (int j = 0; j < N; j++) {
                if (i == j) {
                    continue;
                }
                if (nodes[i][0] >= nodes[j][0] && nodes[i][1] >= nodes[j][1] && nodes[i][2] >= nodes[j][2]) {
                    edges[i].add(j);
                }
            }
        }

        removed = new int[N];
        Arrays.fill(removed, -1);
        for (int i = 0; i < N; i++) {
            isVisited = new boolean[N];
            if (execDFS(i)) {
                delCount++;
            }
            isVisited = new boolean[N];
            if (execDFS(i)) {
                delCount++;
            }
        }

        System.out.println(N - delCount);
    }

    public static void main(String[] args) throws IOException {

        Main main = new Main();
        main.solution();
    }
}
