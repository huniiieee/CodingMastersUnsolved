문제:(네트워크 유량) (에드몬드 카프 알고리즘)
28사단 헌병은 밤마다 1번 막사와 2번 막사 사이를 정찰합니다. 
날이 추워 가만히 있으면 손발이 꽁꽁 얼기 때문에 헌병은 두 막사를 최대한 많이 왕복하려고 합니다. 
두 막사를 제외한 다른 막사에는 처음 도착했을 때만 방문해 정찰일지에 서명을 하고, 그 뒤로는 경로상에 막사가 존재하더라도 들르지 않습니다.
 즉, 왕복을 하는 과정에서 양 끝에 있는 1, 2번 막사를 제외한 경로상의 나머지 막사들은 각각 1번씩만 방문한 것이 됩니다.

막사들은 서로 양방향 길로 이어져 있습니다. 그리고 1번 막사와 2번 막사를 왕복할 때는 반드시 한 개 이상의 다른 막사를 들러야 합니다. 
1번 막사와 2번 막사를 왕복할 수 있는 최대 횟수를 출력하세요.\

답안:
// don't place package name. 

import java.io.*;

import java.util.*; 

// don't change 'Main' class name and  'public' accessor. 

public class Main {
    public static void main(String[] args) throws IOException { 

        Scanner sc = new Scanner(System.in);

        int N = sc.nextInt();  // 막사의 수
        int P = sc.nextInt();  // 길의 수

        List<Integer>[] adj = new ArrayList[N + 1];
        int[][] capacity = new int[N + 1][N + 1];  // 용량
        int[][] flow = new int[N + 1][N + 1];      // 흐름

        // 막사 연결 초기화
        for (int i = 1; i <= N; i++) {
            adj[i] = new ArrayList<>();
        }

        // 길 입력
        for (int i = 0; i < P; i++) {
            int u = sc.nextInt();
            int v = sc.nextInt();
            adj[u].add(v);
            adj[v].add(u);
            capacity[u][v] = 1;  // 양방향 경로
            capacity[v][u] = 1;
        }

        // BFS를 통해 최대 유량 계산
        int totalFlow = 0;
        int source = 1;  //시작
        int sink = 2;    //도착
        final int INF = 1000;

        while (true) {
            // BFS로 증가 경로 찾기
            int[] parent = new int[N + 1];
            Arrays.fill(parent, -1);
            Queue<Integer> queue = new LinkedList<>();
            queue.add(source);
            parent[source] = source;

            // BFS 실행
            while (!queue.isEmpty() && parent[sink] == -1) {
                int u = queue.poll();

                for (int v : adj[u]) {
                    if (capacity[u][v] - flow[u][v] > 0 && parent[v] == -1) {  // 용량이 남아있고, 아직 방문하지 않은 노드
                        queue.add(v);
                        parent[v] = u;
                    }
                }
            }

            if (parent[sink] == -1) break;  // 증가 경로가 없으면 종료

            // 증가 경로를 따라 유량 흘리기
            int amount = INF;
            for (int p = sink; p != source; p = parent[p]) {
                amount = Math.min(amount, capacity[parent[p]][p] - flow[parent[p]][p]);
            }

            for (int p = sink; p != source; p = parent[p]) {
                flow[parent[p]][p] += amount;
                flow[p][parent[p]] -= amount;
            }

            totalFlow += amount;
        }

        // 최대 유량 출력
        System.out.println(totalFlow);
    }
}